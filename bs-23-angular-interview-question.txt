1/arrow function in typescript

const result=(a:number,b:number):number=>{return a+b}
const result=(a:number,b:number):number=>a+b;//arrow function with implecite return;
console.log(result(2,5))

2/arrow function vs normal function

Unlike regular functions, arrow functions do not have their own this.
For example:-

et user = {
    name: "GFG",
    gfg1:() => {
        console.log("hello " + this.name); // no 'this' binding here
    },
    gfg2(){       
        console.log("Welcome to " + this.name); // 'this' binding works here
    }  
 };
user.gfg1();
user.gfg2();

Arguments objects are not available in arrow functions, but are available in regular functions.

let user = {      
    show(){
        console.log(arguments);//possible
    }
};
user.show(1, 2, 3);

let user = {     
        show_ar : () => {
        console.log(...arguments);//not possible
    }
};
user.show_ar(1, 2, 3);

Regular functions created using function declarations or expressions are ‘constructible’ and ‘callable’. Since regular functions are constructible, they can be called using the ‘new’ keyword. However, the arrow functions are only ‘callable’ and not constructible. Thus, we will get a run-time error on trying to construct a non-constructible arrow functions using the new keyword.
let x = function(){
    console.log(arguments);//get success
};
new x =(1,2,3);

et x = ()=> {
    console.log(arguments);//error
};
new x(1,2,3);


3/infinate value pass as a function argument
let x = function(...arg:number[]){
    arg.forEach(value=>{
        console.log(value);
    })
};
x(1,5,7,10,11,40);

CREATE extra environment file
step #1:we will create an interface class for envirnment to define the keys.
step #2:we will then have to pass the values for each environment file.
step #3:we will have to include the details in our configurations in angular.json
make changes under "build->configuration" and under "serve->configuration"
we have to map each environment configuration seperately.
step #4:we can pass the configuration useing the command 
ng serve -configuration=developer.


how interceptor work?
one service class implements httpInterceptor and intercept method take 2 parameter req,next.

export class InterceptorService implements HttpInterceptor {
  token: string;
  constructor(private facadeService: FacadeService) { }

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {

    this.token = this.facadeService.getUserToken();
    if (this.token) {
      const tokenizedReq = req.clone({ headers: req.headers.set('Authorization', 'Bearer ' + this.token) });
      return next.handle(tokenizedReq);
    }
    return next.handle(req);
  }
}

in the app module 

providers: [
 {
  provide: HTTP_INTERCEPTORS,
  useClass: InterceptorService,
  multi: true
 }
]

High-level Differences between Template-driven and Reactive Forms
Below are some of the high-level differences between the two types:

Template-driven forms make use of the "FormsModule", while reactive forms are based on "ReactiveFormsModule".
Template-driven forms are asynchronous in nature, whereas Reactive forms are mostly synchronous.
In a template-driven approach, most of the logic is driven from the template, whereas in reactive-driven approach, the logic resides mainly in the component or typescript code. Let us get started by generating a component and then we'll update our form code.
What is observer and observable? 
Observable is a stream of events or data. They are often returned from Angular methods, such as the http.get and the myinputBox.valueChanges.
Subscribing "kicks off" the observable stream. Without a subscribe (or an async pipe) the stream won't start emitting values.

Observable is like a youtube channel of someone else. 
(( It uploads new videos(data) from time to time, so it is a data source for you))

Your youtube account is an Observer

Your youtube account (Observer) can only get notifications about whether someone else's youtube channel (Observable) has uploaded a new video (has new data) or made a livestream (new event) only if you have subscribed to that channel
Why promise??? 

Promises give us the ability to write cleaner code but reducing (or entirely removing) call-back hell.

In addition, callbacks are the backbone of some new syntax features coming in ES2017, such as async functions, which allows an even cleaner way of writing code.

The third thing that promises do is not immediately apparent when you first learn the syntax -- automatic error handling. Promises allow errors to be passed down
 the chain and handled in one common place without having to put in layers of manual error handling.
 
 Es6 feature
The let keyword
The const keyword
Arrow Functions
Classes
Promises
The For/Of Loop

why promise is used???

 One of the arguments for using promises is getting rid of the so-called "callback hell", which looks something like this:
 setTimeout(function () {
    setTimeout(function() {
        setTimeout(function() {
            // do something
        }); 
    }); 
});
simply using promises alone will also not prevent that, like in the following sample:
samplePromise().then(function () {
    samplePromise().then(function () {
        samplePromise().then( function () {
            // do something
        });
    });
});
That being said, there's one use case that might arguably benefit from a promise, 
and that is when exceptions from more than one asynchronous call could be caught by the same catch block:
new Promise(function (resolve, reject) {
    resolve("Blah");
}).then(function () {
    // do something
}).then(function () {
    // do something
}).catch(function (reason) {
    // error handling
});

generics type in typescript
function getvalue <Type> (args:Type):Type{
    return args;
}
let value:number=getvalue<number>(6)
console.log('value is :',value);
